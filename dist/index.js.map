{"version":3,"sources":["../plugin/index.ts","../plugin/mockServer.ts","../plugin/utils.ts"],"sourcesContent":["import { type Plugin } from 'vite';\nimport type { MockPluginOptions } from './types';\nimport { getMockMiddleware, mockServer } from './mockServer';\n\nexport const viteMockPlugin = (options: MockPluginOptions = {}): Plugin => {\n  const opt = {\n    enable: true,\n    mockPath: 'mock',\n    ...options,\n  };\n  return {\n    name: 'vite-mock-plugin',\n    enforce: 'pre',\n    configResolved: (configResolved) => {\n      const isDev = configResolved.command === 'serve';\n      if (isDev) {\n        mockServer(opt);\n      }\n    },\n    configureServer: (server) => {\n      if (!opt.enable) {\n        return;\n      }\n      server.middlewares.use(getMockMiddleware(opt));\n    },\n  };\n};\n","import { type NextHandleFunction } from 'connect';\nimport type { MockPluginOptions, MockResponse } from './types';\nimport { isAbsPath, isFunction, logInfo } from './utils';\nimport path from 'node:path';\nimport fg from 'fast-glob';\nimport { bundleRequire } from 'bundle-require';\nimport chokidar from 'chokidar';\n\nlet map: Record<string, MockResponse> = {};\nexport async function mockServer({ mockPath }: Required<MockPluginOptions>) {\n  if (Object.keys(map).length) return;\n\n  await getMockContent(mockPath);\n  createWatcher(mockPath);\n}\n\nasync function getMockContent(mockPath: string) {\n  const mockDir = getMockDir(mockPath);\n  const mockFiles = fg.sync('**/*.{js,ts,mjs}', {\n    cwd: mockDir,\n    absolute: true,\n  });\n\n  try {\n    const mods = await Promise.all(\n      mockFiles.map(async (file) => {\n        const res = await bundleRequire({\n          filepath: file,\n        });\n        return res.mod.default || res.mod;\n      })\n    );\n\n    map = mods.reduce((pre, cur) => {\n      return { ...pre, ...cur };\n    }, {});\n  } catch (error) {\n    console.log('load mock file: ', error);\n  }\n}\n\nfunction createWatcher(mockPath: string) {\n  const mockDir = getMockDir(mockPath);\n\n  const watcher = chokidar.watch(mockDir, {\n    ignoreInitial: true,\n    // ignore files generated by `bundle require`\n    ignored: /\\/.*\\.bundled_.*\\.(mjs|cjs)/,\n  });\n\n  watcher.on('all', (event, file) => {\n    logInfo(`mock file ${event}:`, file);\n    getMockContent(mockPath);\n  });\n}\n\nfunction getMockDir(mockPath: string) {\n  const cwd = process.cwd();\n  return isAbsPath(mockPath) ? mockPath : path.join(cwd, mockPath);\n}\n\nexport function getMockMiddleware(options: Required<MockPluginOptions>): NextHandleFunction {\n  return (req, res, next) => {\n    const path = `${req.method} ${req.url}`;\n\n    const resp = map[path] || map[req.url!];\n    if (isFunction(resp)) {\n      resp(req, res);\n      return;\n    }\n    if (resp) {\n      res.setHeader('Content-Type', 'application/json');\n      res.end(JSON.stringify(resp));\n      return;\n    }\n    next();\n  };\n}\n","import colors from 'picocolors';\n\nexport function isAbsPath(path: string | undefined) {\n  if (!path) {\n    return false;\n  }\n  // Windows 路径格式：C:\\ 或 \\\\ 开头，或已含盘符（D:\\path\\to\\file）\n  if (/^([a-zA-Z]:\\\\|\\\\\\\\|(?:\\/|\\uFF0F){2,})/.test(path)) {\n    return true;\n  }\n  // Unix/Linux 路径格式：/ 开头\n  return /^\\/[^/]/.test(path);\n}\n\nfunction log(tag: string) {\n  return (name: string, msg: string) => {\n    console.log([colors.dim(new Date().toLocaleTimeString()), tag, colors.green(name), colors.dim(msg)].join(' '));\n  };\n}\n\nexport const logInfo = log(colors.bold(colors.cyan('[vite:mock]')));\n\nexport const logError = log(colors.bold(colors.red('[vite:mock]')));\n\nexport const isFunction = (val: any): val is Function => typeof val === 'function';\n"],"mappings":"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","names":["path","path"]}