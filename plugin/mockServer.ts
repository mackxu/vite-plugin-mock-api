import { type NextHandleFunction } from 'connect';
import type { MockPluginOptions, MockResponse } from './types';
import { isAbsPath, isFunction, logInfo } from './utils';
import path from 'node:path';
import { bundleRequire } from 'bundle-require';
import chokidar, { FSWatcher } from 'chokidar';
import { glob } from 'node:fs/promises';

let map: Record<string, MockResponse> = {};
export async function mockServer({ mockPath }: Required<MockPluginOptions>) {
  if (Object.keys(map).length > 0) return;

  await getMockContent(mockPath);
  createWatcher(mockPath);
}

async function getMockContent(mockPath: string) {
  const mockDir = getMockDir(mockPath);

  const mockFiles = await Array.fromAsync(
    glob('**/*.{js,ts,mjs}', {
      cwd: mockDir,
    })
  );

  try {
    const mods = await Promise.all(
      mockFiles.map(async (file) => {
        const res = await bundleRequire({
          filepath: path.join(mockDir, file),
        });
        return res.mod.default || res.mod;
      })
    );

    map = mods.reduce((pre, cur) => {
      return { ...pre, ...cur };
    }, {});
    logInfo('mock api count: ', String(Object.keys(map).length));
  } catch (error) {
    console.log('load mock file: ', error);
  }
}

let watcher: FSWatcher;
function createWatcher(mockPath: string) {
  const mockDir = getMockDir(mockPath);

  watcher = chokidar.watch(mockDir, {
    ignoreInitial: true,
    // ignore files generated by `bundle require`
    ignored: /\/.*\.bundled_.*\.(mjs|cjs)/,
  });

  watcher.on('all', (event, file) => {
    logInfo(`mock file ${event}:`, file);
    getMockContent(mockPath);
  });
}

export function closeWatcher() {
  watcher?.close();
}

function getMockDir(mockPath: string) {
  const cwd = process.cwd();
  return isAbsPath(mockPath) ? mockPath : path.join(cwd, mockPath);
}

export function getMockMiddleware(options: Required<MockPluginOptions>): NextHandleFunction {
  return (req, res, next) => {
    const reqUrl = new URL(req.url!, `http://${req.headers.host}`).pathname;

    const resp = map[`${req.method} ${reqUrl}`] || map[reqUrl];
    if (isFunction(resp)) {
      resp(req, res);
      return;
    }
    if (resp) {
      res.setHeader('Content-Type', 'application/json');
      res.end(JSON.stringify(resp));
      return;
    }
    next();
  };
}
