import { type NextHandleFunction } from 'connect';
import type { MockPluginOptions, MockResponse } from './types';
import { isAbsPath, isFunction, logInfo } from './utils';
import path from 'node:path';
import fg from 'fast-glob';
import { bundleRequire } from 'bundle-require';
import chokidar from 'chokidar';

let map: Record<string, MockResponse> = {};
export async function mockServer({ mockPath }: Required<MockPluginOptions>) {
  if (Object.keys(map).length) return;

  await getMockContent(mockPath);
  createWatcher(mockPath);
}

async function getMockContent(mockPath: string) {
  const mockDir = getMockDir(mockPath);
  const mockFiles = fg.sync('**/*.{js,ts,mjs}', {
    cwd: mockDir,
    absolute: true,
  });

  try {
    const mods = await Promise.all(
      mockFiles.map(async (file) => {
        const res = await bundleRequire({
          filepath: file,
        });
        return res.mod.default || res.mod;
      })
    );

    map = mods.reduce((pre, cur) => {
      return { ...pre, ...cur };
    }, {});
  } catch (error) {
    console.log('load mock file: ', error);
  }
}

function createWatcher(mockPath: string) {
  const mockDir = getMockDir(mockPath);

  const watcher = chokidar.watch(mockDir, {
    ignoreInitial: true,
    // ignore files generated by `bundle require`
    ignored: /\/.*\.bundled_.*\.(mjs|cjs)/,
  });

  watcher.on('all', (event, file) => {
    logInfo(`mock file ${event}:`, file);
    getMockContent(mockPath);
  });
}

function getMockDir(mockPath: string) {
  const cwd = process.cwd();
  return isAbsPath(mockPath) ? mockPath : path.join(cwd, mockPath);
}

export function getMockMiddleware(options: Required<MockPluginOptions>): NextHandleFunction {
  return (req, res, next) => {
    const reqUrl = new URL(req.url!, `http://${req.headers.host}`).pathname;

    const resp = map[`${req.method} ${reqUrl}`] || map[reqUrl];
    if (isFunction(resp)) {
      resp(req, res);
      return;
    }
    if (resp) {
      res.setHeader('Content-Type', 'application/json');
      res.end(JSON.stringify(resp));
      return;
    }
    next();
  };
}
